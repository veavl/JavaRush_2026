# Проблема с буфером Scanner - почему нужен nextLine() после next...() методов

## Суть проблемы

Все методы чтения примитивов (`nextInt()`, `nextDouble()`, `nextByte()` и т.д.) **оставляют символ переноса строки `\n` в буфере**. Это вызывает проблемы, когда после них используется `nextLine()`.

## Как работают методы Scanner

### Методы, которые ОСТАВЛЯЮТ `\n` в буфере:

Все методы чтения примитивных типов и `next()`:

- `nextInt()` — читает int, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `nextDouble()` — читает double, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `nextByte()` — читает byte, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `nextFloat()` — читает float, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `nextShort()` — читает short, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `nextLong()` — читает long, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `nextBoolean()` — читает boolean, останавливается на `\n`, **НО НЕ ЧИТАЕТ** сам `\n`
- `next()` — читает слово до пробела/табуляции/`\n`, **НО НЕ ЧИТАЕТ** сам `\n`

### Метод, который ЧИТАЕТ `\n`:

- `nextLine()` — читает всю строку **до конца включительно**, включая символ переноса строки `\n`

## Пример проблемы

### Без очистки буфера:

```java
Scanner sc = new Scanner(System.in);

int a = sc.nextInt();        // Пользователь ввёл: "5\n"
                             // nextInt() читает "5", "\n" остаётся в буфере
                             // Буфер: "\n"

double b = sc.nextDouble();  // Пользователь ввёл: "3.5\n"
                             // nextDouble() читает "3.5", "\n" остаётся в буфере
                             // Буфер: "\n\n"

System.out.print("Введите имя: ");
String name = sc.nextLine(); // ОШИБКА! nextLine() сразу видит "\n\n" 
                             // и возвращает пустую строку, не дожидаясь ввода!
                             // name = ""
```

### С очисткой буфера:

```java
Scanner sc = new Scanner(System.in);

int a = sc.nextInt();        // Ввод: "5\n" → читает "5", "\n" остался
sc.nextLine();               // Очищаем буфер - читаем и выбрасываем "\n"

double b = sc.nextDouble();  // Ввод: "3.5\n" → читает "3.5", "\n" остался
sc.nextLine();               // Очищаем буфер - читаем и выбрасываем "\n"

System.out.print("Введите имя: ");
String name = sc.nextLine(); // Теперь работает корректно! Буфер пуст
                             // Программа ждёт ввода пользователя
```

## Два случая использования nextLine()

### 1. Очистка после успешного чтения примитива

```java
double d1 = sc.nextDouble();  // Пользователь ввёл: "3.5\n"
sc.nextLine();                // Очищаем буфер от символа переноса строки
                              // Чтобы следующий nextLine() работал правильно
```

### 2. Очистка после некорректного ввода

```java
if (!sc.hasNextDouble()) {
    System.out.println("Ошибка! Введите корректное число.");
    sc.nextLine();  // Очищаем буфер от некорректного ввода
                    // Иначе некорректные данные останутся в буфере
                    // и программа зациклится!
    continue;
}
```

## Почему возникает проблема зацикливания при некорректном вводе?

### Без очистки:

```
Введите число №1: abc  ← пользователь ввёл текст
hasNextDouble() → false (это не число)
continue → переход на следующую итерацию
Введите число №1: ???  ← Scanner всё ещё видит "abc\n" в буфере!
hasNextDouble() → false (всё ещё не число)
continue → зацикливание!
```

### С очисткой:

```
Введите число №1: abc  ← пользователь ввёл текст
hasNextDouble() → false
sc.nextLine() → считывает и выбрасывает "abc\n"
Буфер очищен!
continue → переход на следующую итерацию
Введите число №1: ← Scanner готов к новому вводу
```

## Важные моменты

1. **`hasNextDouble()` только проверяет**, но не считывает данные
   - Если проверка не прошла, нужно вручную удалить данные из буфера

2. **`nextDouble()` считывает число**, но оставляет `\n` в буфере
   - После `nextDouble()` всегда используйте `nextLine()` для очистки

3. **`nextLine()` считывает до `\n` включительно**
   - Это единственный метод, который "поедает" символ переноса строки

4. **Проблема касается ВСЕХ `next...()` методов**
   - Не только `nextDouble()`, но и `nextInt()`, `nextByte()`, `next()` и т.д.

## Решение: всегда очищайте буфер

### Правильный паттерн:

```java
// Вариант 1: После чтения примитива
double number = sc.nextDouble();
sc.nextLine();  // Обязательно! Иначе следующий nextLine() пропустит ввод

// Вариант 2: При проверке корректности ввода
if (!sc.hasNextDouble()) {
    sc.nextLine();  // Обязательно! Иначе зацикливание при некорректном вводе
    continue;
}
double number = sc.nextDouble();
sc.nextLine();  // Тоже нужно после чтения!
```

## Альтернативное решение

Вместо смешивания `nextDouble()` и `nextLine()`, можно всегда использовать `nextLine()` и парсить строки:

```java
// Читаем всё как строку
String input = sc.nextLine();
// Парсим в нужный тип
try {
    double number = Double.parseDouble(input);
} catch (NumberFormatException e) {
    System.out.println("Ошибка! Введите корректное число.");
}
```

Этот подход избегает проблем с буфером, но требует дополнительной обработки исключений.

---

**Ключевой вывод:** После любого `next...()` метода (кроме `nextLine()`), если дальше планируется использование `nextLine()`, **всегда вызывайте `sc.nextLine()` для очистки буфера**!


